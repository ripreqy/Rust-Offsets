#pragma once
class Decryption
{
private:
	bool testBITD(uint32_t Value, uint32_t BitPosition) {
		return (Value & (1 << BitPosition)) != 0;
	}

	uintptr_t Il2cppGetHandle(int32_t ptr)
	{
		uint64_t rdi_1 = static_cast<uint32_t>(ptr) >> 3;
		uint64_t rcx_1 = (static_cast<uint32_t>(ptr) & 7) - 1;
		uint64_t baseAddr = globals.game_assembly + Offsets::Il2CppGetHandle + 0x28 * rcx_1;
		uint32_t limit = driver->Read<uint32_t>(baseAddr + 0x10);
		if (rdi_1 < limit) {
			uint64_t objAddr = driver->Read<uint64_t>(baseAddr);
			uint64_t bitMask = driver->Read<uint64_t>(objAddr + ((rdi_1 >> 5) << 2));
			if (testBITD(bitMask, rdi_1 & 0x1f)) {
				uint64_t objectArray = driver->Read<uint64_t>(baseAddr + 0x8) + (rdi_1 << 3);
				return driver->Read<BYTE>(baseAddr + 0x14) > 1 ? driver->Read<uint64_t>(objectArray) : ~driver->Read<uint64_t>(objectArray);
			}
		}
		return 0;
	}

public:
	inline uint64_t client_entities(uint64_t address)
	{
		std::uint32_t r8d = 0, eax = 0, ecx = 0, edx = 0;
		std::uintptr_t rax = driver->Read<std::uintptr_t>(address + 0x18);
		std::uintptr_t* rdx = &rax;
		r8d = 0x02;
		do {
			ecx = *(std::uint32_t*)(rdx);
			eax = *(std::uint32_t*)(rdx);
			rdx = (std::uintptr_t*)((char*)rdx + 0x04);
			ecx >>= 0x1B;
			eax <<= 0x05;
			ecx |= eax;
			ecx -= 0xE7ED9B4;
			ecx ^= 0x1F6ABC70;
			ecx += 0x27EAFFD5;
			*((std::uint32_t*)rdx - 1) = ecx;
			r8d -= 0x01;
		} while (r8d);
		return Il2cppGetHandle(rax);
	}

	inline uint64_t entity_list(uint64_t address)
	{
		std::uint32_t r8d = 0, eax = 0, ecx = 0, edx = 0;
		std::uintptr_t rax = driver->Read<std::uintptr_t>(address + 0x18);
		std::uintptr_t* rdx = &rax;
		r8d = 0x02;
		do {
			eax = *(std::uint32_t*)(rdx);
			rdx = (std::uintptr_t*)((char*)rdx + 0x04);
			eax += 0xFA6E5A7D;
			ecx = eax;
			eax <<= 0x15;
			ecx >>= 0x0B;
			ecx |= eax;
			ecx += 0x16D2B296;
			*((std::uint32_t*)rdx - 1) = ecx;
			r8d -= 0x01;
		} while (r8d);

		return Il2cppGetHandle(rax);
	}

	inline uint64_t decrypt_ClActive_data(uint64_t address)
	{
		std::uint32_t r8d = 0, eax = 0, ecx = 0, edx = 0;
		std::uintptr_t rax = address;
		std::uintptr_t* rdx = &rax;
		r8d = 0x02;
		do {
			eax = *(std::uint32_t*)(rdx);
			rdx = (std::uintptr_t*)((char*)rdx + 0x04);
			eax += 0xA24B0664;
			ecx = eax;
			eax <<= 0x09;
			ecx >>= 0x17;
			ecx |= eax;
			ecx += 0x59ED1ED1;
			eax = ecx;
			ecx <<= 0x0C;
			eax >>= 0x14;
			eax |= ecx;
			*((std::uint32_t*)rdx - 1) = eax;
			r8d -= 0x01;
		} while (r8d);
		return rax;
	}

	inline uintptr_t decrypt_PlayerInventory(uintptr_t address)
	{
		if (!address) return 0;

		std::uint32_t r8d = 0, eax = 0, ecx = 0, edx = 0;
		std::uintptr_t rax = driver->Read<std::uintptr_t>(address + 0x18);
		if (!rax) return 0;

		std::uintptr_t* rdx = &rax;
		r8d = 0x02;
		do {
			ecx = *(std::uint32_t*)(rdx);
			eax = *(std::uint32_t*)(rdx);
			rdx = (std::uintptr_t*)((char*)rdx + 0x04);
			eax <<= 0x0C;
			ecx >>= 0x14;
			ecx |= eax;
			ecx += 0xF149118E;
			eax = ecx;
			ecx <<= 0x09;
			eax >>= 0x17;
			eax |= ecx;
			*((std::uint32_t*)rdx - 1) = eax;
			r8d -= 0x01;
		} while (r8d);
		return Il2cppGetHandle(static_cast<int32_t>(rax));
	}

	inline uintptr_t decrypt_PlayerEyes(uintptr_t a1)
	{
		if (!a1) return 0;

		std::uint32_t r8d = 0, eax = 0, ecx = 0, edx = 0;
		std::uintptr_t rax = driver->Read<std::uintptr_t>(a1 + 0x18);
		if (!rax) return 0;

		std::uintptr_t* rdx = &rax;
		r8d = 0x02;
		do {
			eax = *(std::uint32_t*)(rdx);
			rdx = (std::uintptr_t*)((char*)rdx + 0x04);
			eax += 0x22C8891;
			ecx = eax;
			eax <<= 0x15;
			ecx >>= 0x0B;
			ecx |= eax;
			ecx -= 0x6FE83DD0;
			ecx ^= 0x9E4B9609;
			*((std::uint32_t*)rdx - 1) = ecx;
			r8d -= 0x01;
		} while (r8d);
		return Il2cppGetHandle(static_cast<int32_t>(rax));
	}
} decryption;
